<!DOCTYPE html>
<html lang="en">

<head>
  <title>Davina Griss | Front-end Developer</title>
  <meta charset="utf-8" />
  <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <meta name="theme-color" content="#000000" />
  <meta name="Portfolio template made by Dorota1997, available at GitHub"
    content="Web site created using create-react-app" />
  <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />

  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/devicons/devicon@latest/devicon.min.css">
  <link rel="stylesheet" href="https://pro.fontawesome.com/releases/v5.10.0/css/all.css"
    integrity="sha384-AYmEC3Yw5cVb3ZcuHtOA93w35dYTsvhLPVnYs9eStHfGJvOvKxVfELGroGkvsg+p" crossorigin="anonymous" />
</head>
<style>
  @import url('https://fonts.googleapis.com/css2?family=Roboto&display=swap');

  #magic {

    position: fixed;
    width: 100%;
    height: 100vh;
    display: block;
    top: 0;
    left: 0;
    z-index: -9999;
  }

  .playground {

    /* position: fixed; */
    width: 100%;
    height: 100vh;
    display: block;
    top: 0;
    left: 0;
    display: flex;
    flex-wrap: nowrap;
    flex-direction: column;
    justify-content: flex-end;
    align-items: center;

  }

  .bottomPosition {

    text-align: center;
    margin-bottom: 50px;

  }

  .minText {

    font-size: 14px;
  }
</style>

<body data-theme="light">

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r125/three.min.js"></script>
  <script type="x-shader/x-vertex" id="vertexshader">

      attribute float size;
      attribute vec3 customColor;
      varying vec3 vColor;
    
      void main() {
    
        vColor = customColor;
        vec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );
        gl_PointSize = size * ( 300.0 / -mvPosition.z );
        gl_Position = projectionMatrix * mvPosition;
    
      }
    
    </script>
  <script type="x-shader/x-fragment" id="fragmentshader">

     uniform vec3 color;
     uniform sampler2D pointTexture;
    
     varying vec3 vColor;
    
     void main() {
    
       gl_FragColor = vec4( color * vColor, 1.0 );
       gl_FragColor = gl_FragColor * texture2D( pointTexture, gl_PointCoord );
    
     }
    </script>

  <div id="magic"></div>
  <div class="playground">
    <!-- <div class="bottomPosition">
         <svg class="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 278.8 278.8"><circle fill="#000205" cx="139.4" cy="139.4" r="139.4"/><g fill="none" stroke="#FFF" stroke-width="6.062" stroke-miterlimit="10"><path d="M214 183.4l-74.6 43.1-75.5-43.6V95.8l75.5-43.5 75.4 43.5v59.8l-11.3 6.5z"/><path d="M139.4 226.5l-18.8-38.2 18.8 10.8 75.4-43.5M63.9 95.8l75.3 43.6 75.6-43.6M139.2 139.4v59.7"/></g>
           </svg>
            <h1 class="special">RICARDO SANPRIETO <br><span class="minText">Creative Frontend developer</span></h1>
      </div> -->
  </div>
  <script>
    const preload = () => {

      let manager = new THREE.LoadingManager();
      manager.onLoad = function () {
        const environment = new Environment(typo, particle);
      }

      var typo = null;
      const loader = new THREE.FontLoader(manager);
      const font = loader.load('https://res.cloudinary.com/dydre7amr/raw/upload/v1612950355/font_zsd4dr.json', function (font) { typo = font; });
      const particle = new THREE.TextureLoader(manager).load('https://res.cloudinary.com/dfvtkoboz/image/upload/v1605013866/particle_a64uzf.png');

    }

    if (document.readyState === "complete" || (document.readyState !== "loading" && !document.documentElement.doScroll))
      preload();
    else
      document.addEventListener("DOMContentLoaded", preload);

    class Environment {

      constructor(font, particle) {

        this.font = font;
        this.particle = particle;
        this.container = document.querySelector('#magic');
        this.scene = new THREE.Scene();
        this.createCamera();
        this.createRenderer();
        this.setup()
        this.bindEvents();
      }

      bindEvents() {

        window.addEventListener('resize', this.onWindowResize.bind(this));

      }

      setup() {

        this.createParticles = new CreateParticles(this.scene, this.font, this.particle, this.camera, this.renderer);
      }

      render() {

        this.createParticles.render()
        this.renderer.render(this.scene, this.camera)
      }

      createCamera() {

        this.camera = new THREE.PerspectiveCamera(65, this.container.clientWidth / this.container.clientHeight, 1, 10000);
        this.camera.position.set(0, 0, 100);

      }

      createRenderer() {

        this.renderer = new THREE.WebGLRenderer();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);

        this.renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

        this.renderer.outputEncoding = THREE.sRGBEncoding;
        this.container.appendChild(this.renderer.domElement);

        this.renderer.setAnimationLoop(() => { this.render() })

      }

      onWindowResize() {

        this.camera.aspect = this.container.clientWidth / this.container.clientHeight;
        this.camera.updateProjectionMatrix();
        this.renderer.setSize(this.container.clientWidth, this.container.clientHeight);

      }
    }

    class CreateParticles {

      constructor(scene, font, particleImg, camera, renderer) {

        this.scene = scene;
        this.font = font;
        this.particleImg = particleImg;
        this.camera = camera;
        this.renderer = renderer;

        this.raycaster = new THREE.Raycaster();
        this.mouse = new THREE.Vector2(-200, 200);

        this.colorChange = new THREE.Color();

        this.buttom = false;

        this.data = {

          text: 'Hello World\nIS NOW',
          amount: 1500,
          particleSize: 1,
          particleColor: 0xffffff,
          textSize: 16,
          area: 250,
          ease: .05,
        }

        this.setup();
        this.bindEvents();

      }


      setup() {

        const geometry = new THREE.PlaneGeometry(this.visibleWidthAtZDepth(100, this.camera), this.visibleHeightAtZDepth(100, this.camera));
        const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true });
        this.planeArea = new THREE.Mesh(geometry, material);
        this.planeArea.visible = false;
        this.createText();

      }

      bindEvents() {

        document.addEventListener('mousedown', this.onMouseDown.bind(this));
        document.addEventListener('mousemove', this.onMouseMove.bind(this));
        document.addEventListener('mouseup', this.onMouseUp.bind(this));

      }

      onMouseDown() {

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

        const vector = new THREE.Vector3(this.mouse.x, this.mouse.y, 0.5);
        vector.unproject(this.camera);
        const dir = vector.sub(this.camera.position).normalize();
        const distance = - this.camera.position.z / dir.z;
        this.currenPosition = this.camera.position.clone().add(dir.multiplyScalar(distance));

        const pos = this.particles.geometry.attributes.position;
        this.buttom = true;
        this.data.ease = .01;

      }

      onMouseUp() {

        this.buttom = false;
        this.data.ease = .05;
      }

      onMouseMove() {

        this.mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
        this.mouse.y = - (event.clientY / window.innerHeight) * 2 + 1;

      }

      render(level) {

        const time = ((.001 * performance.now()) % 12) / 12;
        const zigzagTime = (1 + (Math.sin(time * 2 * Math.PI))) / 6;

        this.raycaster.setFromCamera(this.mouse, this.camera);

        const intersects = this.raycaster.intersectObject(this.planeArea);

        if (intersects.length > 0) {

          const pos = this.particles.geometry.attributes.position;
          const copy = this.geometryCopy.attributes.position;
          const coulors = this.particles.geometry.attributes.customColor;
          const size = this.particles.geometry.attributes.size;

          const mx = intersects[0].point.x;
          const my = intersects[0].point.y;
          const mz = intersects[0].point.z;

          for (var i = 0, l = pos.count; i < l; i++) {

            const initX = copy.getX(i);
            const initY = copy.getY(i);
            const initZ = copy.getZ(i);

            let px = pos.getX(i);
            let py = pos.getY(i);
            let pz = pos.getZ(i);

            this.colorChange.setHSL(.5, 1, 1)
            coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b)
            coulors.needsUpdate = true;

            size.array[i] = this.data.particleSize;
            size.needsUpdate = true;

            let dx = mx - px;
            let dy = my - py;
            const dz = mz - pz;

            const mouseDistance = this.distance(mx, my, px, py)
            let d = (dx = mx - px) * dx + (dy = my - py) * dy;
            const f = - this.data.area / d;

            if (this.buttom) {

              const t = Math.atan2(dy, dx);
              px -= f * Math.cos(t);
              py -= f * Math.sin(t);

              this.colorChange.setHSL(.5 + zigzagTime, 1.0, .5)
              coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b)
              coulors.needsUpdate = true;

              if ((px > (initX + 70)) || (px < (initX - 70)) || (py > (initY + 70) || (py < (initY - 70)))) {

                this.colorChange.setHSL(.15, 1.0, .5)
                coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b)
                coulors.needsUpdate = true;

              }

            } else {

              if (mouseDistance < this.data.area) {

                if (i % 5 == 0) {

                  const t = Math.atan2(dy, dx);
                  px -= .03 * Math.cos(t);
                  py -= .03 * Math.sin(t);

                  this.colorChange.setHSL(.15, 1.0, .5)
                  coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b)
                  coulors.needsUpdate = true;

                  size.array[i] = this.data.particleSize / 1.2;
                  size.needsUpdate = true;

                } else {

                  const t = Math.atan2(dy, dx);
                  px += f * Math.cos(t);
                  py += f * Math.sin(t);

                  pos.setXYZ(i, px, py, pz);
                  pos.needsUpdate = true;

                  size.array[i] = this.data.particleSize * 1.3;
                  size.needsUpdate = true;
                }

                if ((px > (initX + 10)) || (px < (initX - 10)) || (py > (initY + 10) || (py < (initY - 10)))) {

                  this.colorChange.setHSL(.15, 1.0, .5)
                  coulors.setXYZ(i, this.colorChange.r, this.colorChange.g, this.colorChange.b)
                  coulors.needsUpdate = true;

                  size.array[i] = this.data.particleSize / 1.8;
                  size.needsUpdate = true;

                }
              }

            }

            px += (initX - px) * this.data.ease;
            py += (initY - py) * this.data.ease;
            pz += (initZ - pz) * this.data.ease;

            pos.setXYZ(i, px, py, pz);
            pos.needsUpdate = true;

          }
        }
      }

      createText() {

        let thePoints = [];

        let shapes = this.font.generateShapes(this.data.text, this.data.textSize);
        let geometry = new THREE.ShapeGeometry(shapes);
        geometry.computeBoundingBox();

        const xMid = - 0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
        const yMid = (geometry.boundingBox.max.y - geometry.boundingBox.min.y) / 2.85;

        geometry.center();

        let holeShapes = [];

        for (let q = 0; q < shapes.length; q++) {

          let shape = shapes[q];

          if (shape.holes && shape.holes.length > 0) {

            for (let j = 0; j < shape.holes.length; j++) {

              let hole = shape.holes[j];
              holeShapes.push(hole);
            }
          }

        }
        shapes.push.apply(shapes, holeShapes);

        let colors = [];
        let sizes = [];

        for (let x = 0; x < shapes.length; x++) {

          let shape = shapes[x];

          const amountPoints = (shape.type == 'Path') ? this.data.amount / 2 : this.data.amount;

          let points = shape.getSpacedPoints(amountPoints);

          points.forEach((element, z) => {

            const a = new THREE.Vector3(element.x, element.y, 0);
            thePoints.push(a);
            colors.push(this.colorChange.r, this.colorChange.g, this.colorChange.b);
            sizes.push(1)

          });
        }

        let geoParticles = new THREE.BufferGeometry().setFromPoints(thePoints);
        geoParticles.translate(xMid, yMid, 0);

        geoParticles.setAttribute('customColor', new THREE.Float32BufferAttribute(colors, 3));
        geoParticles.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.ShaderMaterial({

          uniforms: {
            // color: { value: new THREE.Color( 0x123456 ) },
            color: { value: new THREE.Color(0xffffff) },
            pointTexture: { value: this.particleImg }
          },
          vertexShader: document.getElementById('vertexshader').textContent,
          fragmentShader: document.getElementById('fragmentshader').textContent,

          blending: THREE.AdditiveBlending,
          depthTest: false,
          transparent: true,
        });

        this.particles = new THREE.Points(geoParticles, material);
        this.scene.add(this.particles);

        this.geometryCopy = new THREE.BufferGeometry();
        this.geometryCopy.copy(this.particles.geometry);

      }

      visibleHeightAtZDepth(depth, camera) {

        const cameraOffset = camera.position.z;
        if (depth < cameraOffset) depth -= cameraOffset;
        else depth += cameraOffset;

        const vFOV = camera.fov * Math.PI / 180;

        return 2 * Math.tan(vFOV / 2) * Math.abs(depth);
      }

      visibleWidthAtZDepth(depth, camera) {

        const height = this.visibleHeightAtZDepth(depth, camera);
        return height * camera.aspect;

      }

      distance(x1, y1, x2, y2) {

        return Math.sqrt(Math.pow((x1 - x2), 2) + Math.pow((y1 - y2), 2));
      }
    }

  </script>


  <a href="https://github.com/Dorota1997/react-frontend-dev-portfolio" target="_blank" class="github-corner"
    aria-label="View source on GitHub"><svg width="90" height="90" viewBox="0 0 250 250"
      style="fill:#151513; color:#fff; position: absolute; top: 0; border: 0; left: 0; transform: scale(-1, 1); z-index: 9999"
      aria-hidden="true">
      <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
      <path
        d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
        fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
      <path
        d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
        fill="currentColor" class="octo-body"></path>
    </svg>
    <style>
      .github-corner:hover .octo-arm {
        animation: octocat-wave 560ms ease-in-out
      }

      @keyframes octocat-wave {

        0%,
        100% {
          transform: rotate(0)
        }

        20%,
        60% {
          transform: rotate(-25deg)
        }

        40%,
        80% {
          transform: rotate(10deg)
        }
      }

      @media (max-width:500px) {
        .github-corner:hover .octo-arm {
          animation: none
        }

        .github-corner .octo-arm {
          animation: octocat-wave 560ms ease-in-out
        }
      }
    </style>
  </a>
  <noscript>You need to enable JavaScript to run this app.</noscript>
  <div id="root"></div>
</body>

</html>